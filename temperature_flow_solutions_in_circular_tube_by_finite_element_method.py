# -*- coding: utf-8 -*-
"""Temperature flow solutions in circular tube by finite element method.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1UGRybAoOBmwzOuQ8UiyXBLSQZG0GoQEz
"""

import numpy as np
import itertools
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
from matplotlib import cm
from matplotlib.ticker import LinearLocator, FormatStrFormatter
import timeit
import math
from scipy.interpolate import make_interp_spline, BSpline
#import warnings
#warnings.filterwarnings("ignore", category=np.VisibleDeprecationWarning)

start = timeit.default_timer()
def gen(Nr,Nc):                                 #function that generates connectivity matrix
    out = np.empty((Nr-1,Nc-1,2,3),dtype=int)
    r = np.arange(Nr*Nc).reshape(Nr,Nc)
    out[:,:, 0,0] = r[:-1,:-1]
    out[:,:, 1,0] = r[:-1,1:]
    out[:,:, 0,1] = r[:-1,1:]
    out[:,:, 1,1] = r[1:,1:]
    out[:,:, :,2] = r[1:,:-1,None]
    out.shape =(-1,3)
    return out
def cartesian(*arrays):                         #function that generates the node coordinates  
    mesh = np.meshgrid(*arrays)  
    dim = len(mesh)  
    elements = mesh[0].size  
    flat = np.concatenate(mesh).ravel()  
    reshape = np.reshape(flat, (dim, elements)).T  
    return reshape

Tinf = 433.15    #define all constants
Tinl = 403.15
rho = 739
Cp = 1920
k = 0.22
r0 = 0.0022
z0 = 0.8
rc = 0.00022
g = 12000000
eta_c = 237.2
tau0 = 11786.1
h = 10**6
C = (r0/z0)**2
def dudR(R):                                    #define nonlinear functions
    return r0/eta_c*(2*np.sqrt(tau0*(g*(r0*R-rc)+tau0))-g*r0*R-2*tau0+g*rc)
def Q(R):
    return r0/k*dudR(R)*(np.sqrt(tau0)+np.sqrt(eta_c*abs(dudR(R))*1/r0))**2
def u(R):
    return 1/(6*g*eta_c)*(8*np.sqrt(tau0)*(g*(R*r0-rc)+tau0)**1.5 - 3*(g*R*r0)**2+6*g*(g*rc-2*tau0)*R*r0-8*np.sqrt(tau0)*(g*(r0-rc)+tau0)**1.5+3*(g*r0)**2-6*g*(g*rc-2*tau0)*r0) 
def D(R):
    return u(R)*(rho*Cp*r0**2)/(z0*k)

Nr = 80                                                       #number of nodes in r direction
Nz = Nr                                                        #number of nodes in z direction
lendp = 0                                                      #left endpoint
rendp = 1                                                      #right endpoint
NE = (Nr-1)*(Nz-1)*2                                           #number of elements
r = np.linspace(lendp,rendp,Nr) 
z = np.linspace(lendp,rendp,Nz)
conn = gen(Nr,Nz)                                              #connectivity matrix
node = np.concatenate(np.flipud(np.split(cartesian(r,z),Nr)))  #node coordinates
Ae = .5*(r[Nr-1]-r[Nr-2])**2                                   #area of a triangle element
K = np.zeros((Nz**2,Nr**2))                                    # global stiffness matrix
F = np.zeros((Nr**2,1))                                        # global force vector

def vertex(elem,index):                            # i, j, k positions of local nodes
    return conn[elem][index]                                         
def a_i(elem):
    return node[vertex(elem,1)][0]*node[vertex(elem,2)][1] - node[vertex(elem,2)][0]*node[vertex(elem,1)][1]
def a_j(elem):
    return node[vertex(elem,2)][0]*node[vertex(elem,0)][1]-node[vertex(elem,0)][0]*node[vertex(elem,2)][1]
def a_k(elem):
    return node[vertex(elem,0)][0]*node[vertex(elem,1)][1]-node[vertex(elem,1)][0]*node[vertex(elem,0)][1]
def b_i(elem):
    return node[vertex(elem,1)][1]-node[vertex(elem,2)][1]
def b_j(elem):
    return node[vertex(elem,2)][1]-node[vertex(elem,0)][1]
def b_k(elem):
    return node[vertex(elem,0)][1]-node[vertex(elem,1)][1]
def c_i(elem):
    return node[vertex(elem,2)][0]-node[vertex(elem,1)][0]
def c_j(elem):
    return node[vertex(elem,0)][0]-node[vertex(elem,2)][0]
def c_k(elem):
    return node[vertex(elem,1)][0]-node[vertex(elem,0)][0]
def r_av(elem):
    return (1/3)*(node[vertex(elem,0)][0]+node[vertex(elem,1)][0]+node[vertex(elem,2)][0])

def elstiff1(elem):
    m = np.zeros((3,3)); n = np.zeros((3,3))
    m[0][0] = b_i(elem)**2; m[1][1] = b_j(elem)**2; m[2][2] = b_k(elem)**2
    m[1][0] = b_i(elem)*b_j(elem); m[0][1] = b_i(elem)*b_j(elem); m[2][0] = b_i(elem)*b_k(elem)
    m[0][2] = b_i(elem)*b_k(elem); m[2][1] = b_j(elem)*b_k(elem); m[1][2] = b_j(elem)*b_k(elem)
    n[0][0] = c_i(elem)**2; n[1][1] = c_j(elem)**2; n[2][2] = c_k(elem)**2
    n[1][0] = c_i(elem)*c_j(elem); n[0][1] = c_i(elem)*c_j(elem); n[2][0] = c_i(elem)*c_k(elem)
    n[0][2] = c_i(elem)*c_k(elem); n[2][1] = c_j(elem)*c_k(elem); n[1][2] = c_j(elem)*c_k(elem)
    return np.pi*r_av(elem)/(2*Ae)*(m+C*n)

def boundary_elements(Nr):
    el = np.arange(2*(Nr-1)**2)
    bel = np.zeros(Nr-1)
    for i in range(Nr-1):
        bel[i] = np.split(el, Nr-1)[i][-1]
    return bel

def elstiff2(elem):            #boundary contributions only
    m = np.zeros((3,3)); m[0][0] = 3*node[vertex(elem,0)][0]+node[vertex(elem,1)][0];
    m[0][1] = node[vertex(elem,0)][0]+node[vertex(elem,1)][0]; m[1][0] = node[vertex(elem,0)][0]+node[vertex(elem,1)][0];
    m[1][1] = node[vertex(elem,0)][0]+3*node[vertex(elem,1)][0];
    return (np.pi*h*(r[Nr-1]-r[Nr-2])/6)*m

def elstiff3(elem):
    l1 = [1/3, 0.0597159, 0.470142, 0.470142, 0.101287, 0.797427, 0.101287];
    l2 = [1/3, 0.470142, 0.470142, 0.0597159, 0.101287, 0.101287, 0.797427];
    w = [0.11250, 0.0661971, 0.0661971, 0.0661971, 0.0629696, 0.0629696, 0.0629696];
    rsum = np.zeros((3,3))
    J = (node[vertex(elem,0)][0]-node[vertex(elem,2)][0])*(node[vertex(elem,1)][1]-node[vertex(elem,2)][1])-(node[vertex(elem,1)][0]-node[vertex(elem,2)][0])*(node[vertex(elem,0)][1]-node[vertex(elem,2)][1])
    for i in range(7):
      m = np.zeros((3,3))
      m[0][0] = l1[i]/(2*Ae)*c_i(elem); m[1][0] = l2[i]/(2*Ae)*c_i(elem); m[2][0] = (1-l1[i]-l2[i])/(2*Ae)*c_i(elem);
      m[0][1] = l1[i]/(2*Ae)*c_j(elem); m[1][1] = l2[i]/(2*Ae)*c_j(elem); m[2][1] = (1-l1[i]-l2[i])/(2*Ae)*c_j(elem); 
      m[0][2] = l1[i]/(2*Ae)*c_k(elem); m[1][2] = l2[i]/(2*Ae)*c_k(elem); m[2][2] = (1-l1[i]-l2[i])/(2*Ae)*c_k(elem); 
      xii = (l1[i]*node[vertex(elem,0)][0]+l2[i]*node[vertex(elem,1)][0]+(1-l1[i]-l2[i])*node[vertex(elem,2)][0])
      rsum = rsum + w[i]*m*D(xii)*xii 
    return np.pi*J*rsum

def elvector1(elem):       #boundary contributions only
    m = np.zeros((3,1)); m[0]=2*node[vertex(elem,0)][0]+node[vertex(elem,1)][0];
    m[1] = node[vertex(elem,0)][0]+2*node[vertex(elem,1)][0]
    return np.pi*h*Tinf*(r[Nr-1]-r[Nr-2])/3*m

def elvector2(elem):
    l1 = [1/3, 0.0597159, 0.470142, 0.470142, 0.101287, 0.797427, 0.101287]
    l2 = [1/3, 0.470142, 0.470142, 0.0597159, 0.101287, 0.101287, 0.797427]
    w = [0.11250, 0.0661971, 0.0661971, 0.0661971, 0.0629696, 0.0629696, 0.0629696]
    rsum = np.zeros((3,1))
    J = (node[vertex(elem,0)][0]-node[vertex(elem,2)][0])*(node[vertex(elem,1)][1]-node[vertex(elem,2)][1])-(node[vertex(elem,1)][0]-node[vertex(elem,2)][0])*(node[vertex(elem,0)][1]-node[vertex(elem,2)][1])
    for i in range(7):
      m = np.zeros((3,1))
      m[0][0] = l1[i]; m[1][0] = l2[i]; m[2][0] = (1-l1[i]-l2[i])
      xii = (l1[i]*node[vertex(elem,0)][0]+l2[i]*node[vertex(elem,1)][0]+(1-l1[i]-l2[i])*node[vertex(elem,2)][0])
      rsum = rsum + w[i]*m*Q(xii) 
    return np.pi*J*rsum

def contribute():
    for x in range(NE):
        for i in range(3):
            ii = conn[x][i]
            F[ii] = F[ii] + elvector2(x)[i]
            for j in range(3):
                jj = conn[x][j]
                K[ii][jj] = K[ii][jj] + elstiff1(x)[i][j]+elstiff3(x)[i][j]

def contribute_boundary():
    for x in boundary_elements(Nr):
        for i in range(3):
            ii = conn[int(x)][i]
            F[ii] = F[ii] + elvector1(int(x))[i]
            for j in range(3):
                jj = conn[int(x)][j]
                K[ii][jj] = K[ii][jj] + elstiff2(int(x))[i][j]

def del_rows(K, F):
    dirichlet_ind = np.split(np.arange(Nr**2),Nr)[-1]
    d = list(dirichlet_ind)[:-1]
    K = np.delete(K,d,0)
    F = np.delete(F,d,0)
    return K,F

contribute()
contribute_boundary()
K,F = del_rows(K,F)

def column(matrix, pos):
    return np.asarray([row[pos] for row in matrix]).reshape(Nr**2-Nr+1,1)

def apply_dirichlet(K,F):
    dirichlet_ind = np.split(np.arange(Nr**2),Nr)[-1]
    d = list(dirichlet_ind)[:-1]
    for i in d:
      F = F - Tinl*column(K,i)
    K = np.delete(K,d,1)
    return K,F

K,F = apply_dirichlet(K,F)
solution_set = np.linalg.solve(K,F)

def plot(solution_set):
    dirichlet_values = [Tinl]*(Nr-1)
    last = list(np.concatenate(solution_set))[-1]
    new = list(np.concatenate(solution_set))[:-1]
    join = new + dirichlet_values
    join.append(last)
    T = np.asarray(join).reshape(Nr,Nz)
    rr, zz = np.meshgrid(r,z)
    f = plt.figure()
    h = f.add_subplot(111, projection='3d')
    h.set_zlim(403, 434)
    h.zaxis.set_major_locator(LinearLocator(5))
    h.zaxis.set_major_formatter(FormatStrFormatter('%.0f'))
    h.set_xlim(1,0)
    h.set_xlabel('R')
    h.set_ylabel('Z')
    h.set_zlabel('T (Kelvin)')
    surf = h.plot_surface(rr, zz, np.flipud(T), rstride=2, cstride=3, cmap=cm.jet, edgecolor='k')
    f.colorbar(surf, shrink=0.4, aspect=5)
    print("Number of elements: ", NE)
    print("Maximum temperature: ", T.max())
    h.view_init(azim=300)
    #print(len(T))
    #print(T[0])
    #print(T[24])
    #print(T[49])
    #print(T[74])
    #print(T[98])
    #R = np.linspace(0,1,80) 
    #plt.plot(R, T[78], label = 'Z = 0.025')
    #plt.plot(R, T[70], label = 'Z = 0.15')
    #plt.plot(R, T[60], label = 'Z = 0.35')
    #plt.plot(R, T[39], label = 'Z = 0.50')
    #plt.plot(R, T[1], label = 'Z = 1')
    #plt.legend(title = 'Location along Z',bbox_to_anchor=(1.05, 1), loc='upper left')
    #plt.xlabel('R')
    #plt.ylabel('Temperature (K)')
    #plt.grid()
    #plt.show()
plot(solution_set)

"""This part solves the same problem without Z"""

t1 = [407.03031159, 407.03044903, 407.03117291, 407.0325443,  407.03457952,
 407.03729504, 407.04071169, 407.04485553, 407.0497583,  407.05545759,
 407.06199698, 407.06942621, 407.07780128, 407.08718453, 407.09764477,
 407.10925742, 407.12210465, 407.13627559, 407.1518665,  407.16898099,
 407.18773022, 407.20823311, 407.23061658, 407.25501575, 407.28157416,
 407.31044401, 407.34178634, 407.37577127, 407.41257816, 407.45239581,
 407.49542263, 407.54186677, 407.5919463,  407.64588924, 407.7039337,
 407.7663279,  407.8333302,  407.90520905, 407.98224295, 408.06472033,
 408.15293941, 408.24720797, 408.34784309, 408.45517082, 408.56952582,
 408.69125085, 408.8206963,  408.95821955, 409.1041843,  409.25895982,
 409.42292007, 409.59644282, 409.77990857, 409.97369949, 410.17819815,
 410.39378629, 410.62084336, 410.85974504, 411.1108617,  411.37455662,
 411.65118429, 411.9410885,  412.24460037, 412.56203635, 412.89369599,
 413.23985983, 413.60078705, 413.97671313, 414.36784745, 414.77437078,
 415.19643282, 415.63414958, 416.08760084, 416.55682752, 417.04182907,
 417.54256084, 418.0589315,  418.59080041, 419.13797506, 419.7002086,
 420.2771973,  420.86857819, 421.47392669, 422.09275434, 422.72450667,
 423.36856102, 424.02422465, 424.69073279, 425.36724686, 426.05285283,
 426.74655963, 427.44729769, 428.15391758, 428.86518875, 429.57979834,
 430.29635009, 431.01336333, 431.72927195, 432.44242348, 433.15107814]
t2 = [431.77944357, 431.77926481, 431.77967536, 431.78072765, 431.78242315,
 431.7847578,  431.78772608, 431.79132195, 431.79553916, 431.80037129,
 431.80581185, 431.81185422, 431.81849169, 431.82571734, 431.833524,
 431.84190418, 431.85085007, 431.86035352, 431.87040599, 431.88099855,
 431.89212191, 431.90376634, 431.91592173, 431.92857755, 431.94172286,
 431.9553463,  431.9694361,  431.98398008, 431.99896567, 432.01437985,
 432.03020925, 432.04644006, 432.06305812, 432.08004886, 432.09739736,
 432.11508832, 432.13310611, 432.15143474, 432.17005789, 432.18895893,
 432.20812094, 432.22752668, 432.24715867, 432.26699915, 432.28703012,
 432.30723337, 432.32759047, 432.3480828,  432.36869157, 432.38939785,
 432.41018256, 432.43102652, 432.45191045, 432.47281499, 432.49372075,
 432.51460829, 432.53545817, 432.55625097, 432.57696727, 432.59758774,
 432.6180931,  432.6384642,  432.65868196, 432.67872748, 432.698582,
 432.71822695, 432.73764395, 432.75681485, 432.77572174, 432.79434698,
 432.81267319, 432.83068331, 432.84836058, 432.86568859, 432.88265127,
 432.89923294, 432.91541828, 432.93119239, 432.94654079, 432.96144942,
 432.97590469, 432.98989344, 433.003403,   433.0164212,  433.02893635,
 433.04093727, 433.05241332, 433.06335437, 433.07375085, 433.08359373,
 433.09287454, 433.10158539, 433.10971895, 433.11726849, 433.12422787,
 433.13059155, 433.13635458, 433.14151263, 433.14606202, 433.14999965]
t3 = [433.50196841, 433.50141992, 433.50095259, 433.50056876, 433.50026363,
 433.50003187, 433.49986827, 433.49976781, 433.49972572, 433.49973745,
 433.49979872, 433.49990546, 433.50005378, 433.50023992, 433.50046018,
 433.50071087, 433.50098832, 433.5012888, 433.50160859, 433.5019439,
 433.50229089, 433.50264569, 433.50300434, 433.50336286, 433.50371718,
 433.50406319, 433.50439669, 433.50471345, 433.50500917, 433.50527947,
 433.50551994, 433.50572607, 433.50589334, 433.50601712, 433.50609276,
 433.50611554, 433.50608067, 433.50598332, 433.50581861, 433.50558158,
 433.50526726, 433.50487058, 433.50438646, 433.50380975, 433.50313527,
 433.50235777, 433.50147197, 433.50047254, 433.49935412, 433.4981113,
 433.49673863, 433.49523062, 433.49358175, 433.49178645, 433.48983914,
 433.48773418, 433.48546592, 433.48302868, 433.48041673, 433.47762432,
 433.4746457,  433.47147507, 433.4681066,  433.46453445, 433.46075278,
 433.45675569, 433.45253729, 433.44809167, 433.44341289, 433.43849502,
 433.43333208, 433.42791812, 433.42224715, 433.41631318, 433.41011021,
 433.40363225, 433.39687326, 433.38982724, 433.38248817, 433.37485001,
 433.36690674, 433.35865232, 433.35008073, 433.34118593, 433.33196189,
 433.32240258, 433.31250198, 433.30225405, 433.29165278, 433.28069215,
 433.26936614, 433.25766876, 433.245594,   433.23313587, 433.22028837,
 433.20704553, 433.19340138, 433.17934996, 433.16488531, 433.15000149]
t4 = [433.58097944, 433.580414,   433.57990641, 433.57945672, 433.57905983,
 433.57871036, 433.57840312, 433.57813311, 433.57789566, 433.57768629,
 433.57750083, 433.57733531, 433.57718599, 433.57704924, 433.57692152,
 433.57679933, 433.57667916, 433.57655752, 433.57643089, 433.57629571,
 433.57614841, 433.57598536, 433.57580292, 433.57559737, 433.57536499,
 433.57510197, 433.57480449, 433.57446866, 433.57409057, 433.57366624,
 433.57319166, 433.57266276, 433.57207544, 433.57142555, 433.57070891,
 433.56992126, 433.56905833, 433.5681158, 433.5670893, 433.56597443,
 433.56476674, 433.56346174, 433.56205491, 433.56054168, 433.55891745,
 433.55717758, 433.55531738, 433.55333215, 433.55121712, 433.54896751,
 433.54657849, 433.54404521, 433.54136277, 433.53852625, 433.53553068,
 433.53237107, 433.5290424,  433.52553961, 433.5218576,  433.51799126,
 433.51393544, 433.50968496, 433.5052346,  433.50057913, 433.49571328,
 433.49063174, 433.4853292,  433.4798003,  433.47403966, 433.46804187,
 433.4618015,  433.45531308, 433.44857114, 433.44157015, 433.43430459,
 433.42676888, 433.41895745, 433.41086469, 433.40248494, 433.39381257,
 433.38484189, 433.37556718, 433.36598274, 433.3560828,  433.34586159,
 433.33531332, 433.32443217, 433.31321231, 433.30164788, 433.289733,
 433.27746177, 433.26482827, 433.25182655, 433.23845067, 433.22469464,
 433.21055246, 433.19601811, 433.18108555, 433.16574873, 433.15000158]
t5 = [433.58464382, 433.58406637, 433.58354579, 433.5830832,  433.58267323,
 433.58231034, 433.58198922, 433.58170479, 433.58145226, 433.58122712,
 433.58102511, 433.5808422,  433.58067461, 433.58051868, 433.58037083,
 433.58022756, 433.58008535, 433.57994069, 433.57979005, 433.57962989,
 433.57945662, 433.57926663, 433.57905626, 433.57882181, 433.57855955,
 433.5782657,  433.57793642, 433.57756786, 433.57715609, 433.57669716,
 433.57618706, 433.57562174, 433.57499711, 433.57430905, 433.57355336,
 433.57272582, 433.57182219, 433.57083814, 433.56976934, 433.5686114,
 433.5673599,  433.56601036, 433.56455829, 433.56299914, 433.56132834,
 433.55954126, 433.55763326, 433.55559964, 433.55343568, 433.55113662,
 433.54869767, 433.546114,   433.54338074, 433.54049301, 433.53744587,
 433.53423437, 433.53085353, 433.52729831, 433.52356366, 433.51964452,
 433.51553576, 433.51123226, 433.50672883, 433.50202029, 433.49710142,
 433.49196696, 433.48661163, 433.48103014, 433.47521716, 433.46916733,
 433.46287526, 433.45633557, 433.4495428,  433.44249152, 433.43517625,
 433.42759148, 433.41973169, 433.41159133, 433.40316483, 433.3944466,
 433.38543101, 433.37611244, 433.36648521, 433.35654365, 433.34628204,
 433.33569466, 433.32477575, 433.31351954, 433.30192024, 433.28997201,
 433.27766902, 433.2650054,  433.25197526, 433.23857268, 433.22479172,
 433.21062642, 433.19607079, 433.18111881, 433.16576443, 433.15000159]
R = np.linspace(0,1,100) 
plt.plot(R, t1, label = 'Z = 0.01')
plt.plot(R, t2, label = 'Z = 0.25')
plt.plot(R, t3, label = 'Z = 0.50')
plt.plot(R, t4, label = 'Z = 0.75')
plt.plot(R, t5, label = 'Z = 1')
plt.legend(bbox_to_anchor=(1.05, 1), loc='upper left')
plt.xlabel('R')
plt.grid()
plt.show()

def parametric_study(r0,rc,Tinl,Tinf,g):
  #Tinf = 433.15    #define all constants
  #Tinl = 403.15
  rho = 739
  Cp = 1920
  k = 0.22
  #r0 = 0.0019
  z0 = 0.8
  #rc = 0.00019
  #g = 12000000
  eta_c = 237.2
  tau0 = 11786.1
  h = 10**6
  C = (r0/z0)**2
  def dudR(R):                                    #define nonlinear functions
      return r0/eta_c*(2*np.sqrt(tau0*(g*(r0*R-rc)+tau0))-g*r0*R-2*tau0+g*rc)
  def Q(R):
      return r0/k*dudR(R)*(np.sqrt(tau0)+np.sqrt(eta_c*abs(dudR(R))*1/r0))**2
  def u(R):
      return 1/(6*g*eta_c)*(8*np.sqrt(tau0)*(g*(R*r0-rc)+tau0)**1.5 - 3*(g*R*r0)**2+6*g*(g*rc-2*tau0)*R*r0-8*np.sqrt(tau0)*(g*(r0-rc)+tau0)**1.5+3*(g*r0)**2-6*g*(g*rc-2*tau0)*r0) 
  def D(R):
      return u(R)*(rho*Cp*r0**2)/(z0*k)
  Nr = 100                                                        #number of nodes in r direction
  Nz = Nr                                                        #number of nodes in z direction
  lendp = 0                                                      #left endpoint
  rendp = 1                                                      #right endpoint
  NE = (Nr-1)*(Nz-1)*2                                           #number of elements
  r = np.linspace(lendp,rendp,Nr) 
  z = np.linspace(lendp,rendp,Nz)
  conn = gen(Nr,Nz)                                              #connectivity matrix
  node = np.concatenate(np.flipud(np.split(cartesian(r,z),Nr)))  #node coordinates
  Ae = .5*(r[Nr-1]-r[Nr-2])**2                                   #area of a triangle element
  K = np.zeros((Nz**2,Nr**2))                                    # global stiffness matrix
  F = np.zeros((Nr**2,1))                                        # global force vector
  def vertex(elem,index):                            # i, j, k positions of local nodes
    return conn[elem][index]                                         
  def a_i(elem):
      return node[vertex(elem,1)][0]*node[vertex(elem,2)][1] - node[vertex(elem,2)][0]*node[vertex(elem,1)][1]
  def a_j(elem):
      return node[vertex(elem,2)][0]*node[vertex(elem,0)][1]-node[vertex(elem,0)][0]*node[vertex(elem,2)][1]
  def a_k(elem):
      return node[vertex(elem,0)][0]*node[vertex(elem,1)][1]-node[vertex(elem,1)][0]*node[vertex(elem,0)][1]
  def b_i(elem):
      return node[vertex(elem,1)][1]-node[vertex(elem,2)][1]
  def b_j(elem):
      return node[vertex(elem,2)][1]-node[vertex(elem,0)][1]
  def b_k(elem):
      return node[vertex(elem,0)][1]-node[vertex(elem,1)][1]
  def c_i(elem):
      return node[vertex(elem,2)][0]-node[vertex(elem,1)][0]
  def c_j(elem):
      return node[vertex(elem,0)][0]-node[vertex(elem,2)][0]
  def c_k(elem):
      return node[vertex(elem,1)][0]-node[vertex(elem,0)][0]
  def r_av(elem):
      return (1/3)*(node[vertex(elem,0)][0]+node[vertex(elem,1)][0]+node[vertex(elem,2)][0])
  def elstiff1(elem):
    m = np.zeros((3,3)); n = np.zeros((3,3))
    m[0][0] = b_i(elem)**2; m[1][1] = b_j(elem)**2; m[2][2] = b_k(elem)**2
    m[1][0] = b_i(elem)*b_j(elem); m[0][1] = b_i(elem)*b_j(elem); m[2][0] = b_i(elem)*b_k(elem)
    m[0][2] = b_i(elem)*b_k(elem); m[2][1] = b_j(elem)*b_k(elem); m[1][2] = b_j(elem)*b_k(elem)
    n[0][0] = c_i(elem)**2; n[1][1] = c_j(elem)**2; n[2][2] = c_k(elem)**2
    n[1][0] = c_i(elem)*c_j(elem); n[0][1] = c_i(elem)*c_j(elem); n[2][0] = c_i(elem)*c_k(elem)
    n[0][2] = c_i(elem)*c_k(elem); n[2][1] = c_j(elem)*c_k(elem); n[1][2] = c_j(elem)*c_k(elem)
    return np.pi*r_av(elem)/(2*Ae)*(m+C*n)
  def boundary_elements(Nr):
    el = np.arange(2*(Nr-1)**2)
    bel = np.zeros(Nr-1)
    for i in range(Nr-1):
        bel[i] = np.split(el, Nr-1)[i][-1]
    return bel
  def elstiff2(elem):            #boundary contributions only
    m = np.zeros((3,3)); m[0][0] = 3*node[vertex(elem,0)][0]+node[vertex(elem,1)][0];
    m[0][1] = node[vertex(elem,0)][0]+node[vertex(elem,1)][0]; m[1][0] = node[vertex(elem,0)][0]+node[vertex(elem,1)][0];
    m[1][1] = node[vertex(elem,0)][0]+3*node[vertex(elem,1)][0];
    return (np.pi*h*(r[Nr-1]-r[Nr-2])/6)*m
  def elstiff3(elem):
    l1 = [1/3, 0.0597159, 0.470142, 0.470142, 0.101287, 0.797427, 0.101287];
    l2 = [1/3, 0.470142, 0.470142, 0.0597159, 0.101287, 0.101287, 0.797427];
    w = [0.11250, 0.0661971, 0.0661971, 0.0661971, 0.0629696, 0.0629696, 0.0629696];
    rsum = np.zeros((3,3))
    J = (node[vertex(elem,0)][0]-node[vertex(elem,2)][0])*(node[vertex(elem,1)][1]-node[vertex(elem,2)][1])-(node[vertex(elem,1)][0]-node[vertex(elem,2)][0])*(node[vertex(elem,0)][1]-node[vertex(elem,2)][1])
    for i in range(7):
      m = np.zeros((3,3))
      m[0][0] = l1[i]/(2*Ae)*c_i(elem); m[1][0] = l2[i]/(2*Ae)*c_i(elem); m[2][0] = (1-l1[i]-l2[i])/(2*Ae)*c_i(elem);
      m[0][1] = l1[i]/(2*Ae)*c_j(elem); m[1][1] = l2[i]/(2*Ae)*c_j(elem); m[2][1] = (1-l1[i]-l2[i])/(2*Ae)*c_j(elem); 
      m[0][2] = l1[i]/(2*Ae)*c_k(elem); m[1][2] = l2[i]/(2*Ae)*c_k(elem); m[2][2] = (1-l1[i]-l2[i])/(2*Ae)*c_k(elem); 
      xii = (l1[i]*node[vertex(elem,0)][0]+l2[i]*node[vertex(elem,1)][0]+(1-l1[i]-l2[i])*node[vertex(elem,2)][0])
      rsum = rsum + w[i]*m*D(xii)*xii 
    return np.pi*J*rsum
  def elvector1(elem):       #boundary contributions only
    m = np.zeros((3,1)); m[0]=2*node[vertex(elem,0)][0]+node[vertex(elem,1)][0];
    m[1] = node[vertex(elem,0)][0]+2*node[vertex(elem,1)][0]
    return np.pi*h*Tinf*(r[Nr-1]-r[Nr-2])/3*m
  def elvector2(elem):
    l1 = [1/3, 0.0597159, 0.470142, 0.470142, 0.101287, 0.797427, 0.101287]
    l2 = [1/3, 0.470142, 0.470142, 0.0597159, 0.101287, 0.101287, 0.797427]
    w = [0.11250, 0.0661971, 0.0661971, 0.0661971, 0.0629696, 0.0629696, 0.0629696]
    rsum = np.zeros((3,1))
    J = (node[vertex(elem,0)][0]-node[vertex(elem,2)][0])*(node[vertex(elem,1)][1]-node[vertex(elem,2)][1])-(node[vertex(elem,1)][0]-node[vertex(elem,2)][0])*(node[vertex(elem,0)][1]-node[vertex(elem,2)][1])
    for i in range(7):
      m = np.zeros((3,1))
      m[0][0] = l1[i]; m[1][0] = l2[i]; m[2][0] = (1-l1[i]-l2[i])
      xii = (l1[i]*node[vertex(elem,0)][0]+l2[i]*node[vertex(elem,1)][0]+(1-l1[i]-l2[i])*node[vertex(elem,2)][0])
      rsum = rsum + w[i]*m*Q(xii) 
    return np.pi*J*rsum
  def contribute():
    for x in range(NE):
        for i in range(3):
            ii = conn[x][i]
            F[ii] = F[ii] + elvector2(x)[i]
            for j in range(3):
                jj = conn[x][j]
                K[ii][jj] = K[ii][jj] + elstiff1(x)[i][j]+elstiff3(x)[i][j]
  def contribute_boundary():
    for x in boundary_elements(Nr):
        for i in range(3):
            ii = conn[int(x)][i]
            F[ii] = F[ii] + elvector1(int(x))[i]
            for j in range(3):
                jj = conn[int(x)][j]
                K[ii][jj] = K[ii][jj] + elstiff2(int(x))[i][j]  
  def del_rows(K, F):
    dirichlet_ind = np.split(np.arange(Nr**2),Nr)[-1]
    d = list(dirichlet_ind)[:-1]
    K = np.delete(K,d,0)
    F = np.delete(F,d,0)
    return K,F
  contribute()
  contribute_boundary()
  K,F = del_rows(K,F)
  def column(matrix, pos):
    return np.asarray([row[pos] for row in matrix]).reshape(Nr**2-Nr+1,1)
  def apply_dirichlet(K,F):
    dirichlet_ind = np.split(np.arange(Nr**2),Nr)[-1]
    d = list(dirichlet_ind)[:-1]
    for i in d:
      F = F - Tinl*column(K,i)
    K = np.delete(K,d,1)
    return K,F
  K,F = apply_dirichlet(K,F)
  solution_set = np.linalg.solve(K,F)
  dirichlet_values = [Tinl]*(Nr-1)
  last = list(np.concatenate(solution_set))[-1]
  new = list(np.concatenate(solution_set))[:-1]
  join = new + dirichlet_values
  join.append(last)
  T = np.asarray(join).reshape(Nr,Nz)
  T = np.flipud(T)
  total = []
  for i in range(Nr-1):
    a = []
    for j in range(Nr-1):
      s = (T[i+1][j]-T[i][j])/T[i][j]
      a.append(s)
      total.append(s)
      if (max(a)<0.0001):
        break
  return math.ceil(len(total)/Nr)/Nr

def parametric_curve(n,Tinl,Tinf,g):
  r = []
  l = []
  for i in range(n):
    R = 0.0019+0.0001*i
    Rc = 0.00019+0.00001*i
    r.append(R)
    l.append(parametric_study(R,Rc,Tinl,Tinf,g))
  l = [800*x for x in l]
  r = [1000*x for x in r]
  print(r)
  print(l)
  plt.xlabel('Radius (mm)')
  plt.ylabel('Optimal length (mm)')
  plt.plot(r,l)

def parametric_curves_Tinl(m, Tinf):
  for i in range(m):
    Tinl = 403.15 + 9*i
    parametric_curve(10,Tinl, Tinf,12000000)
  plt.grid()
  plt.show()

parametric_curves_Tinl(4,433.15)

tinl1 = [152.0, 184.0, 216.0, 256.0, 296.0, 344.0, 400.0, 440.00000000000006, 512.0, 584.0]
tinl2 = [144.0, 168.0, 200.0, 240.0, 272.0, 320.0, 368.0, 408.0, 463.99999999999994, 536.0]
tinl3 = [128.0, 152.0, 184.0, 208.0, 240.0, 280.0, 320.0, 360.0, 408.0, 455.99999999999994]
tinl4 = [96.0, 112.00000000000001, 136.0, 144.0, 168.0, 200.0, 224.00000000000003, 248.0, 280.0, 312.0]
R = [1.9, 2.0, 2.1, 2.2, 2.3, 2.4000000000000004, 2.5, 2.6, 2.7, 2.8]
plt.plot(R,tinl1,label = '403.15 K')
plt.plot(R,tinl2,label = '412.15 K')
plt.plot(R,tinl3,label = '421.15 K')
plt.plot(R,tinl4,label = '430.15 K')
plt.xlabel('Radius (mm)')
plt.ylabel('$L_{req}$ (mm)')
plt.legend(title = 'Inlet temperature')
plt.grid()
plt.show()

def parametric_curves_Tinf(m, Tinl):
  for i in range(m):
    Tinf = 433.15 + 9*i
    parametric_curve(10,Tinl, Tinf, 12000000)
  plt.show()

parametric_curves_Tinf(4, 403.15)

tinf1 = [152.0, 184.0, 216.0, 256.0, 296.0, 344.0, 400.0, 440.00000000000006, 512.0, 584.0]
tinf2 = [160.0, 192.0, 224.00000000000003, 272.0, 304.0, 360.0, 408.0, 463.99999999999994, 536.0, 616.0]
tinf3 = [160.0, 192.0, 231.99999999999997, 280.0, 320.0, 376.0, 424.0, 488.0, 560.0, 640.0]
tinf4 = [168.0, 200.0, 240.0, 288.0, 328.0, 384.0, 440.00000000000006, 504.0, 576.0, 656.0]
R = [1.9, 2.0, 2.1, 2.2, 2.3, 2.4000000000000004, 2.5, 2.6, 2.7, 2.8]
plt.plot(R,tinf1,label = '433.15 K')
plt.plot(R,tinf2,label = '442.15 K')
plt.plot(R,tinf3,label = '451.15 K')
plt.plot(R,tinf4,label = '460.15 K')
plt.xlabel('Radius (mm)')
plt.ylabel('$L_{req}$ (mm)')
plt.legend(title = 'Wall temperature')
plt.grid()
plt.show()

def parametric_curves_pressure(m,Tinl,Tinf):
  for i in range(m):
    g = 12000000 + 800000*i
    parametric_curve(10,Tinl, Tinf,g)
  plt.show()

parametric_curves_pressure(4,403.15,433.15)

g1 = [152.0, 184.0, 216.0, 256.0, 296.0, 344.0, 400.0, 440.00000000000006, 512.0, 584.0]
g2 = [168.0, 200.0, 231.99999999999997, 272.0, 320.0, 376.0, 424.0, 480.0, 552.0, 616.0]
g3 = [176.0, 216.0, 256.0, 296.0, 344.0, 400.0, 448.00000000000006, 520.0, 592.0, 672.0]
g4 = [192.0, 231.99999999999997, 264.0, 312.0, 368.0, 424.0, 488.0, 560.0, 632.0, 720.0]
R = [1.9, 2.0, 2.1, 2.2, 2.3, 2.4000000000000004, 2.5, 2.6, 2.7, 2.8]
plt.plot(R,g1,label = '12 MPa')
plt.plot(R,g2,label = '12.8 MPa')
plt.plot(R,g3,label = '13.6 MPa')
plt.plot(R,g4,label = '14.4 MPa')
plt.xlabel('Radius (mm)')
plt.ylabel('$L_{req}$ (mm)')
plt.legend(title = 'Pressure drop')
plt.grid()
plt.show()

def parametric_curve(n,Tinl,Tinf,g):
  r = []
  l = []
  for i in range(n):
    R = 0.002+0.0002*i
    Rc = 0.0002+0.00002*i
    r.append(R)
    l.append(parametric_study(R,Rc,Tinl,Tinf,g))
  l = [800*x for x in l]
  r = [1000*x for x in r]
  print(r)
  print(l)
  plt.xlabel('Radius (mm)')
  plt.ylabel('Optimal length (mm)')
  plt.plot(r,l)

def parametric_curves_pressure(m,Tinl,Tinf):
  for i in range(m):
    g = 12000000 + 100000*i
    parametric_curve(5,Tinl, Tinf,g)
  plt.show()

parametric_curves_pressure(16,403.15,433.15)

r0 = 0.002
rc = 0.0002
#qq = []
qqq = []
for i in range(16):
  g = (12000000 + 100000*i)
  flow_rate = 2*(g/3*eta_c*(rc**3-r0**3)+(g*rc*r0*(r0-rc)-tau0*r0**2+2*tau0*rc*r0-tau0*rc**2)/eta_c+(4*tau0**.5*(g*(r0-rc)+tau0)**1.5*(3*g*(r0-rc)-2*tau0)+8*tau0**3)/(15*g**2*eta_c)+rc*(8*tau0**2-3*g**2*rc**2+6*g*(g*rc-2*tau0)*rc-8*tau0**.5*(g*(r0-rc)+tau0)**1.5+3*g**2*r0**2-6*g*(g*rc-2*tau0)*r0)/(6*g*eta_c))
  #qq.append(abs(flow_rate)/61024) 
  qqq.append(abs(flow_rate)*rho*np.pi)
print(qqq)
  #print(abs(flow_rate)/61024)